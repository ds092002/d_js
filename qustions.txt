https://github.com/shubhdhungana/mern-interview-sets-pdf/blob/main/2.0%20JS%20Interview%20Questions.pdf



### **Basics of Node.js**
1. **What is Node.js?**  
   Node.js is an open-source, cross-platform runtime environment that executes JavaScript code outside a browser, built on Chrome's V8 JavaScript engine.  

2. **What are the key features of Node.js?**  
   - **Asynchronous and Event-Driven:** Non-blocking operations.  
   - **Single-Threaded:** Handles multiple requests in a single thread using event loops.  
   - **Fast Execution:** Built on the V8 engine.  
   - **Cross-Platform:** Runs on Windows, Linux, and macOS.  

3. **What is the difference between Node.js and JavaScript?**  
   - JavaScript is a programming language used for client-side development.  
   - Node.js is a runtime environment for executing JavaScript on the server side.  

---

### **Modules and Architecture**
4. **What is the Node.js module system?**  
   The Node.js module system allows developers to encapsulate code into reusable modules. There are built-in, third-party, and user-defined modules.  

5. **What is the difference between `require()` and `import`?**  
   - `require()`: CommonJS module system, used in Node.js.  
   - `import`: ES6 module system, supports static imports.  

6. **What is the purpose of the `package.json` file?**  
   The `package.json` file contains metadata about a Node.js project, including dependencies, scripts, and versioning.  

7. **What is the purpose of the `module.exports` and `exports`?**  
   - `module.exports`: Used to export a single item (function, object, etc.).  
   - `exports`: A shorthand for adding properties to `module.exports`.  

---

### **Event Loop and Asynchronous Programming**
8. **What is the event loop in Node.js?**  
   The event loop is a mechanism that allows Node.js to perform non-blocking I/O operations by offloading tasks to the system kernel and processing them asynchronously.

9. **What is the difference between asynchronous and synchronous programming?**  
   - **Asynchronous:** Non-blocking; operations run in the background.  
   - **Synchronous:** Blocking; operations are executed sequentially.  

10. **What are callbacks in Node.js?**  
    A callback is a function passed as an argument to another function, executed after an asynchronous operation completes.  
    ```javascript
    fs.readFile('file.txt', (err, data) => {
        if (err) throw err;
        console.log(data.toString());
    });
    ```

---

### **File System and Streams**
11. **How do you read a file in Node.js?**  
    Using the `fs` module:    
    ```javascript
    const fs = require('fs');
    fs.readFile('file.txt', 'utf8', (err, data) => {
        if (err) throw err;
        console.log(data);
    });
    ```

12. **What are streams in Node.js?**  
    Streams are used to handle reading/writing data in chunks, instead of loading the entire data at once. Types of streams:  
    - **Readable:** For reading data.  
    - **Writable:** For writing data.  
    - **Duplex:** For both reading and writing.  
    - **Transform:** For modifying data while reading/writing.

0---

### **Middleware and Frameworks**
13. **What is middleware in Node.js?**  
    Middleware functions in Node.js are functions that have access to the request, response, and `next()` in the application‚Äôs request-response cycle.  

14. **What is Express.js?**  
    Express.js is a lightweight, flexible framework for Node.js that simplifies handling requests, routing, and middleware.

15. **How do you set up a simple server in Express.js?**  
    ```javascript
    const express = require('express');
    const app = express();
    app.get('/', (req, res) => res.send('Hello World!'));
    app.listen(3000, () => console.log('Server running on port 3000'));
    ```

---

### **APIs and HTTP**
16. **What is RESTful API in Node.js?**  
    A RESTful API follows the REST architectural style, using standard HTTP methods (GET, POST, PUT, DELETE) for communication.

17. **How do you handle errors in Node.js?**  
    By using try-catch blocks, middleware, or the `error` event:  
    ```javascriptc
    app.use((err, req, res, next) => {
        console.error(err.stack);
        res.status(500).send('Something went wrong!');
    });
    ```

18. **What is the `http` module in Node.js?**  
    The `http` module allows Node.js to create servers and handle HTTP requests and responses.  
    Example:  
    ```javascript
    const http = require('http');
    const server = http.createServer((req, res) => {
        res.end('Hello, Node.js!');
    });
    server.listen(3000);
    ```

---

### **Database**
19. **Which databases can you use with Node.js?**  
    - Relational: MySQL, PostgreSQL.  
    - NoSQL: MongoDB, CouchDB.  

20. **How do you connect Node.js to a MongoDB database?**  
    Using the `mongoose` library:  
    ```javascript
    const mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost:27017/mydb', { useNewUrlParser: true, useUnifiedTopology: true });
    ```

---
### **Advanced Topics**
21. **What is clustering in Node.js?**  
    Clustering allows Node.js to utilize multiple cores of a processor, creating child processes to handle multiple requests concurrently.

----

## Node.js Interview Q&A

### Basic Level

**1. What is Node.js?**  
Node.js is an open-source, cross-platform JavaScript runtime built on Chrome's V8 engine. It allows developers to run JavaScript on the server side to build scalable network applications.

**2. What are the key features of Node.js?**  
- Event-driven and asynchronous
- Fast execution due to the V8 engine
- Single-threaded but handles concurrency using the event loop
- No buffering ‚Äî outputs data in chunks
- Cross-platform

**3. What is the difference between synchronous and asynchronous code in Node.js?**
- **Synchronous**: Code is executed line-by-line, blocking the next line until the current line completes.  
- **Asynchronous**: Code doesn't wait and can execute other tasks while waiting for operations like I/O to complete (using callbacks, promises, or async/await).
Example:

// Synchronous````````````````````
console.log("Start");
console.log("End");

// Asynchronous
setTimeout(() => {
  console.log("End after timeout");
}, 1000);
console.log("Start");

**4. What is the role of the package.json file?**  
It holds metadata about the project and manages dependencies, scripts, versions, entry points, and more.

{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.17.1"
  }
}

**5. What is NPM? How is it used?**  
NPM (Node Package Manager) is the default package manager for Node.js. It is used to install, manage, and publish packages or dependencies.

**6. What is a callback function?**  
A callback is a function passed into another function as an argument, which is then executed after a certain operation is completed.

function greet(name, callback) {
  console.log("Hello, " + name);
  callback();
}

greet("Alice", () => console.log("Callback executed!"));

**7. What is the difference between var, let, and const in Node.js?**  
- `var` is function-scoped.  
- `let` and `const` are block-scoped.  
- `const` is used for values that should not be reassigned.

let name = "Alice";
const age = 30;

if (true) {
  let name = "Bob";  // Block-scoped
  console.log(name);  // Output: Bob
}

console.log(name);  // Output: Alice

**8. What is a module in Node.js?**  
A module is a reusable block of code whose existence does not accidentally impact other code. Node.js has built-in modules and supports custom modules.

// math.js
module.exports.add = function(a, b) {
  return a + b;
};

// app.js
const math = require('./math');
console.log(math.add(2, 3));  // Output: 5

**9. How do you export a function in Node.js?**  
Use `module.exports = functionName` to export and `require('./file')` to import.

// greeting.js
module.exports = function(name) {
  return `Hello, ${name}!`;
};

// app.js
const greet = require('./greeting');
console.log(greet("Alice"));

**10. How do you read environment variables in Node.js?**  
Use `process.env.VARIABLE_NAME` to access environment variables.


console.log(process.env.NODE_ENV);  // Output: production (if set)
---

### Intermediate Level

**11. Explain the event loop in Node.js.**  
The event loop is a mechanism that handles asynchronous operations in Node.js. It allows Node.js to perform non-blocking I/O by offloading operations to the system and listening for their completion.

console.log("Start");

setTimeout(() => {
  console.log("Timeout completed");
}, 0);

console.log("End");

**12. What are streams in Node.js?**  
Streams are objects that let you read data or write data continuously. Types include Readable, Writable, Duplex, and Transform.

const fs = require('fs');
const readableStream = fs.createReadStream('example.txt', 'utf8');
readableStream.on('data', (chunk) => {
  console.log(chunk);
});

**13. What is the difference between require() and import?**  
- `require()` is used in CommonJS modules (default in Node.js).  
- `import` is used in ES6 modules and requires enabling it via package.json or file extension `.mjs`.

// Using require()
const fs = require('fs');
                                   
// Using import (ES6 Modules)
import fs from 'fs';

**14. How does Node.js handle child processes?**  
Using the `child_process` module, Node.js can spawn new processes1 to handle tasks concurrently, useful for CPU-intensive tasks.

const { exec } = require('child_process');
exec('ls', (err, stdout, stderr) => {
  if (err) {
    console.log(`exec error: ${err}`);
    return;
  }
  console.log(`stdout: ${stdout}`);`
  console.log(`stderr: ${stderr}`);
});

**15. What is middleware in Express.js?**  
Middleware are functions that have access to `req`, `res`, and `next()`. They are used to execute code, modify request/response, and end the request-response cycle.


const express = require('express');
const app = express();

app.use((req, res, next) => {
  console.log('Request received');
  next();
});

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000);

**16. How do you handle errors in async code?**  
- Using callbacks with error-first conventions  
- Using try/catch with async/await  
- Using `.catch()` with promises

// Using try/catch with async/await
async function fetchData() {
  try {
    const data = await someAsyncOperation();
  } catch (error) {
    console.error(error);
  }
}

**17. What is the difference between process.nextTick(), setImmediate(), and setTimeout()?**  
- `process.nextTick()`: Executes after the current operation, before I/O events.  
- `setImmediate()`: Executes after I/O events.  
- `setTimeout()`: Executes after a specified delay.

process.nextTick(() => console.log("nextTick"));                
setImmediate(() => console.log("setImmediate"));
setTimeout(() => console.log("setTimeout"), 0);

**18. What is Express.js?**  
Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for building web applications and APIs.

const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello, Express!');
});

app.listen(3000);

**19. How do you connect a Node.js app to a database?**  
Use a database driver or ORM like Mongoose for MongoDB or SequeliFe for SQL databases.

const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/mydb', { useNewUrlParser: true, useUnifiedTopology: true });

**20. What are Promises in Node.js?**  
Promises are objects representing the eventual completion or failure of an asynchronous operation, allowing better handling of async code.

const promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("Data fetched successfully");
  } else {
    reject("Error fetching data");
  }
});

promise
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
---

### Advanced Level

**21. What is the concept of clustering in Node.js and why is it used?**  
Clustering allows Node.js to use multiple cores by spawning child processes (workers) that share the same server port, improving performance and scalability.

const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('Hello, Node.js Cluster!');
  }).listen(8000);
}

**22. How would you manage memory leaks in a Node.js application?**  
- Use tools like `heapdump`, `clinic.js`, or Chrome DevTools  
- Monitor memory usage  
- Avoid global variables  
- Close unused resources  
- Use weak references

const heapdump = require('heapdump');
heapdump.writeSnapshot('./my-app.heapsnapshot');


**23. Explain how to secure a Node.js application.**  
- Use Helmet for HTTP headers  
- Sanitize inputs to prevent injection attacks  
- Use HTTPS  
- Manage environment variables securely  
- Implement rate limiting and authentication

const helmet = require('helmet');
const express = require('express');
const app = express();

app.use(helmet());


**24. How do you optimize performance in Node.js?**  
- Use asynchronous/non-blocking code  
- Leverage clustering and worker threads  
- Use caching (e.g., Redis)  
- Avoid memory leaks  
- Profile and monitor performance

const redis = require('redis');
const client = redis.createClient();
client.set('key', 'value', redis.print);


**25. What are worker threads in Node.js?**  
Worker threads enable multithreading in Node.js for CPU-bound tasks. They run in separate threads and can share memory using `SharedArrayBuffer`.

const { Worker } = require('worker_threads');

const worker = new Worker('./worker.js');
worker.on('message', (msg) => console.log(msg));
worker.postMessage('Hello from main thread');


**26. What is the difference between microservices and monolithic architecture in Node.js apps?**  
- **Monolithic**: Single large application  
- **Microservices**: Application is split into smaller, independent services that communicate via APIs

// Monolithic - one server handles everything
const express = require('express');
const app = express();
app.get('/user', (req, res) => res.send('User route'));
app.get('/order', (req, res) => res.send('Order route'));
app.listen(3000);

// Microservices - each service has its own server
// userService.js
const express = require('express');
const userApp = express();
userApp.get('/user', (req, res) => res.send('User route'));
userApp.listen(3001);

// orderService.js
const express = require('express');
const orderApp = express();
orderApp.get('/order', (req, res) => res.send('Order route'));
orderApp.listen(3002);


**27. How does Node.js handle concurrency if it‚Äôs single-threaded?**  
Node.js uses a single-threaded event loop with non-blocking I/O and background threads in the libuv library to handle concurrent operations.

const fs = require('fs');

console.log("Start");

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log("File read complete");
});

console.log("End");

// Output:
// Start
// End
// File read complete


**28. Explain the internals of the Node.js event loop with an example.**  
The event loop handles different phases (timers, pending callbacks, idle, poll, check, close callbacks). Each phase has a FIFO queue of callbacks.

```js
setTimeout(() => console.log("timeout"), 0);
setImmediate(() => console.log("immediate"));
process.nextTick(() => console.log("nextTick"));
```

Output:
```
nextTick
immediate or timeout (depends on context)
```

**29. What are some common use cases for Node.js?**  
- Real-time applications (e.g., chat apps)  
- RESTful APIs and backend services  
/* REST (Representational State Transfer) ‡™®‡™æ principles ‡™™‡™∞ ‡™Ü‡™ß‡™æ‡™∞‡™ø‡™§ ‡™π‡´ã‡™Ø ‡™õ‡´á. RESTful API ‡™®‡´ã ‡™Æ‡´Å‡™ñ‡´ç‡™Ø ‡™π‡´á‡™§‡´Å ‡™õ‡´á ‡™¨‡´á system (‡™Æ‡´ã‡™ü‡´á‡™≠‡™æ‡™ó‡´á client ‡™Ö‡™®‡´á server) ‡™µ‡™ö‡´ç‡™ö‡´á data exchange ‡™ï‡™∞‡™µ‡´ã ‡™∏‡™∞‡™≥, standardized ‡™Ö‡™®‡´á scalable ‡™∞‡´Ä‡™§‡´á.*/
- Single Page Applications (SPA) backends  
- Data streaming services  
- IoT applications
// Real-time chat using socket.io
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIO(server);0

io.on('connection', (socket) => {
  socket.on('message', (msg) => {
    socket.broadcast.emit('message', msg);
  });
});

server.listen(3000, () => console.log('Server started'));


**30. What is the purpose of the 'buffer' module in Node.js?**  
The `buffer` module is used to handle binary data directly in memory. It is particularly useful when dealing with streams or reading from binary files.

const buffer = Buffer.from('Hello');
console.log(buffer);             // <Buffer 48 65 6c 6c 6f>
console.log(buffer.toString()); // Hello


**31. What is the role of the 'path' module in Node.js?**  
The `path` module provides utilities for working with file and directory paths in a cross-platform way.

const path = require('path');

console.log(__dirname); // Current directory
console.log(path.join(__dirname, 'file.txt')); // Cross-platform safe path


**32. What is the difference between spawn() and exec() in child_process?**  
- `spawn()`: Launches a new process with a given command and streams data.  
- `exec()`: Executes a command in a shell and buffers the output.

const { exec, spawn } = require('child_process');

// exec buffers output
exec('ls', (err, stdout, stderr) => {
  if (err) throw err;
  console.log('exec output:', stdout);
});

// spawn streams output
const child = spawn('ls');
child.stdout.on('data', (data) => {
  console.log('spawn output:', data.toString());
});


**33. How does Node.js handle file system operations?**  
Node.js uses the `fs` module to perform file operations. It provides both synchronous and asynchronous methods for reading, writing, and managing files.

const fs = require('fs');

// Asynchronous read
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log('Async Read:', data);
});

// Synchronous read
const data = fs.readFileSync('file.txt', 'utf8');
console.log('Sync Read:', data);


**34. What is an event emitter in Node.js?**  
An event emitter is an object from the `events` module that allows binding and emitting custom events. It's a key part of the event-driven architecture in Node.js.

const EventEmitter = require('events');
const emitter = new EventEmitter();

emitter.on('greet', (name) => {
  console.log(`Hello, ${name}`);
});

emitter.emit('greet', 'Alice');


**35. What are environment variables and how are they used in Node.js?**  
Environment variables store configuration outside of your code. In Node.js, they can be accessed using `process.env`. They are typically used for sensitive data like API keys.

// In .env file: API_KEY=12345

console.log(process.env.API_KEY); // Access environment variable


**36. What is the difference between __dirname and ./ in Node.js?**  
- `__dirname`: Absolute path of the directory containing the current module.  
- `./`: Relative path based on the current working directory.

console.log('__dirname:', __dirname);           // Absolute path
console.log('relative path:', './file.txt');    // Relative to process.cwd()


**37. What is the purpose of the 'util' module in Node.js?**  
The `util` module provides helpful functions like `promisify`, `inherits`, `inspect`, and more for debugging and extending functionalities.

const util = require('util');
const fs = require('fs');

const readFile = util.promisify(fs.readFile);
readFile('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err));


**38. How do you prevent blocking the event loop in Node.js?**  
By offloading CPU-intensive tasks to worker threads, using asynchronous APIs, and ensuring long operations do not run synchronously on the main thread.

const { Worker } = require('worker_threads');

function runWorker() {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./heavyTask.js');
    worker.on('message', resolve);
    worker.on('error', reject);
  });
}
runWorker().then(result => console.log(result));


**39. What is the difference between synchronous and asynchronous file read methods in Node.js?**  
Synchronous methods block execution until the operation is complete, while asynchronous methods allow other operations to continue.

const fs = require('fs');

// Synchronous (blocking)
const data = fs.readFileSync('file.txt', 'utf8');
console.log('Sync:', data);

// Asynchronous (non-blocking)
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log('Async:', data);
});


**40. What is a memory leak and how do you detect it in Node.js?**  
A memory leak occurs when memory that is no longer needed is not released. Tools like Chrome DevTools, Node.js Inspector, and heap snapshots can help detect them.

// Simulating a memory leak
const leaks = [];
setInterval(() => {
  leaks.push(new Array(1000000).fill('*'));
  console.log(`Leak size: ${leaks.length}`);
}, 1000);

// To detect: use Chrome DevTools or --inspect flag
// node --inspect index.js


**41. How can you debug a Node.js application?**  
Use `console.log()`, the built-in `debugger`, or tools like `node inspect`, Chrome DevTools, or VS Code Debugger.

let x = 10;
debugger; // Execution will pause here if debugging
console.log('Value of x:', x);

// Run using: node inspect script.js or attach debugger in VS Code


**42. What are timers in Node.js?**  
Timers like `setTimeout()`, `setInterval()`, and `setImmediate()` are functions that execute code after a delay or at regular intervals.

setTimeout(() => console.log('After 1 sec'), 1000);
setInterval(() => console.log('Every 2 sec'), 2000);
setImmediate(() => console.log('Runs immediately after current event loop'));


**43. What is a REPL in Node.js?**  
REPL (Read-Eval-Print Loop) is a command-line interface for executing JavaScript code interactively.

$ node
> const x = 5;
> x * 2
10
> .exit


**44. What is a package-lock.json file?**  
`package-lock.json` records the exact version of installed dependencies, ensuring consistent installs across environments.

// Example snippet from package-lock.json
{
  "name": "demo-app",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "dependencies": {
    "express": {
      "version": "4.17.1"
    }
  }
}


**45. What is global scope in Node.js?**  
Global scope means variables or functions that can be accessed anywhere in the code. However, Node.js limits pollution by wrapping modules in a function.

global.myVar = 'Accessible globally';
console.log(myVar); // Prints: Accessible globally


**46. What is the role of libuv in Node.js?**  
Libuv is a C library that provides an event loop and asynchronous I/O for Node.js, enabling non-blocking behavior.

const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => {
  console.log('Read using non-blocking I/O');
});


**47. What is the 'os' module in Node.js?**  
The `os` module provides information about the operating system, such as CPU, memory, and network interfaces.

const os = require('os');
console.log('Free memory:', os.freemem());
console.log('CPU info:', os.cpus());


**48. What is the purpose of the 'http' module in Node.js?**  
The `http` module allows you to create HTTP servers and handle requests and responses directly.

const http = require('http');
const server = http.createServer((req, res) => {
  res.end('Hello from HTTP server');
});
server.listen(3000, () => console.log('Server running on port 3000'));


**49. How do you implement authentication in a Node.js app?**  
Using packages like Passport.js or JWT, along with session or token-based strategies.

const jwt = require('jsonwebtoken');
const token = jwt.sign({ userId: 123 }, 'secretkey');
console.log(token);

const verified = jwt.verify(token, 'secretkey');
console.log(verified.userId); // 123


**50. What is CORS and how do you handle it in Node.js?**  
CORS (Cross-Origin Resource Sharing) is a security feature that restricts access to resources. It can be handled using the `cors` middleware in Express.

const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors()); // Enable CORS
app.get('/', (req, res) => res.send('CORS enabled'));
app.listen(3000);


**51. How do you handle rate limiting in Node.js APIs?**  
Use middleware like `express-rate-limit` to limit repeated requests to public APIs and routes, helping prevent abuse or DDoS attacks.

const rateLimit = require('express-rate-limit');
const express = require('express');
const app = express();

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});

app.use(limiter);


**52. What is the difference between middleware and route handlers in Express.js?**  
Middleware functions execute before the final route handler and can modify `req`, `res`, or pass control. Route handlers are the endpoints that send the final response.

app.use((req, res, next) => {
  console.log('Middleware executed');
  next();
});

app.get('/user', (req, res) => {
  res.send('Route handler');
});


**53. How do you use JWT in Node.js for authentication?**  
Use the `jsonwebtoken` package to sign user data and send it as a token. On subsequent requests, verify this token to authenticate the user.

const jwt = require('jsonwebtoken');
const token = jwt.sign({ id: 1 }, 'secret', { expiresIn: '1h' });
console.log(token);

const decoded = jwt.verify(token, 'secret');
console.log(decoded.id); // 1


**54. What is server-side rendering (SSR) and how does Node.js support it?**  
SSR is rendering a web page on the server instead of the client. Node.js supports SSR with frameworks like Next.js or by manually rendering templates with engines like EJS, Pug, or Handlebars.

app.set('view engine', 'ejs');

app.get('/', (req, res) => {
  res.render('index', { message: 'Server-side Rendered Page' });
});


**55. What are some popular libraries or frameworks built on Node.js?**  
- Express.js  
- Koa  
- NestJS  
- Hapi  
- Socket.io  
- Next.js (for SSR)

const express = require('express'); // Popular framework


**56. What is the difference between global and local packages in Node.js?**  
- **Global**: Installed system-wide using `-g`. Accessible via CLI anywhere.  
- **Local**: Installed in project folder. Used as project dependencies.

npm install -g nodemon    # global
npm install express       # local


**57. How do you monitor a Node.js application in production?**  
Use tools like PM2, New Relic, AppDynamics, or custom logging/metrics with Winston or Morgan.

pm2 start app.js
pm2 monit


**58. What is hot reloading, and how do you implement it in Node.js?**  
Hot reloading automatically restarts the server on code changes. Tools like `nodemon` or `pm2` with `--watch` enable this.

npm install --save-dev nodemon
npx nodemon app.js


**59. How does async_hooks work in Node.js?**  
The `async_hooks` module allows tracking the lifecycle of asynchronous resources, useful for debugging and performance profiling.

const async_hooks = require('async_hooks');

const hook = async_hooks.createHook({
  init(asyncId, type) {
    console.log(`AsyncHook Init: ${type} (${asyncId})`);
  }
});
hook.enable();


**60. How can you protect sensitive configuration data in a Node.js project?**  
Use environment variables and `.env` files with libraries like `dotenv`. Avoid committing sensitive data to version control.

require('dotenv').config();
console.log(process.env.DB_PASSWORD);
.env file:
DB_PASSWORD=mysecret


üîπ 1. What is Object-Oriented Programming (OOP)?
‚úÖ Answer:

Object-Oriented Programming is a programming paradigm based on the concept of "objects", which contain both data (properties) and methods (functions). It focuses on principles like encapsulation, inheritance, polymorphism, and abstraction to make code more modular, reusable, and easier to maintain.

üîπ 2. How is OOP used in Node.js?
‚úÖ Answer:

Node.js supports OOP through JavaScript's class syntax. We use classes to define blueprints for objects, and we can use inheritance to reuse logic between objects. OOP is often used in Node.js to structure code in large applications like Express.js projects, services, and database models.

üîπ 3. What are the four pillars of OOP?
‚úÖ Answer:

Encapsulation: Hiding internal state and requiring all interaction to be performed through an object‚Äôs methods.

Abstraction: Hiding complex implementation details and showing only the necessary parts.

Inheritance: Sharing functionality between classes via a parent-child relationship.

Polymorphism: Using a single interface to represent different underlying forms (methods behave differently depending on the object calling them).

üîπ 4. Can you show an example of OOP in Node.js?
// Base class
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

// Derived class
class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog('Buddy');
dog.speak(); // Buddy barks.
‚úÖ What it shows:

Inheritance (Dog extends Animal)

Polymorphism (Overriding speak)

Encapsulation (properties inside class)

üîπ 5. Why use OOP in Node.js when JS is also functional?
‚úÖ Answer:

OOP makes complex systems easier to manage by grouping related data and behavior. In large-scale Node.js apps (like APIs or services), using OOP leads to better structure, reusable code, and maintainability. You can combine both paradigms as JavaScript supports OOP and functional programming.

üèÜ One Commonly Used OOP Answer:
When asked any OOP question, this phrase is often your go-to answer:

"OOP allows me to model real-world entities as classes, encapsulate related logic, and write scalable, maintainable code using inheritance and abstraction."








1. **What is MERN stack?**
   - MERN stands for MongoDB, Express.js, React.js, and Node.js. It is a full-stack JavaScript framework used to build web applications.

2. **What is MongoDB?**
   - MongoDB is a NoSQL database that stores data in JSON-like documents with flexible schemas.

3. **What is Express?**
   - Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.

4. **What is Node?**
   - Node.js is a JavaScript runtime built on Chrome's V8 engine that allows you to run JavaScript on the server side.

5. **What is React?**
   - React is a JavaScript library for building user interfaces, focusing on component-based architecture and efficient rendering using a virtual DOM.

6. **What is a token?**
   - A token is a piece of data used for authentication and authorization purposes in web applications.

7. **Why use tokens?**
   - Tokens are used to securely transmit information between parties and to manage user authentication and authorization.

8. **Difference between JavaScript and TypeScript?**
   - JavaScript is a dynamically typed scripting language, whereas TypeScript is a statically typed superset of JavaScript with optional type annotations.

9. **What is middleware?**
   - Middleware functions in Express.js are functions that have access to the request and response objects and can modify them before passing them to the next function.

10. **Why use middleware?**
   - Middleware is used to handle tasks like authentication, logging, error handling, and request processing.

11. **Why use MongoDB?**
   - MongoDB offers flexibility, scalability, and high performance, making it suitable for modern web applications.

12. **What is DSA?**
   - Data Structures and Algorithms (DSA) are a set of techniques to organize, manage, and store data efficiently.

13. **What is LinkedList?**
   - A LinkedList is a linear data structure consisting of nodes where each node contains data and a reference to the next node.

14. **What is Stack in DSA?**
   - A stack is a linear data structure that follows the LIFO (Last In, First Out) principle.

15. **What is Queue in DSA?**
   - A queue is a linear data structure that follows the FIFO (First In, First Out) principle.

16. **Types of sorting in DSA?**
   - Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort, and Counting Sort.

17. **What is Linear Search in DSA?**
   - Linear Search is a searching algorithm that sequentially checks each element in a list until the desired element is found.

18. **What is Binary Search in DSA?**
   - Binary Search is an efficient searching algorithm that divides the search space in half at each step.

19. **Difference between let, var, const?**
   - `var` has function scope, `let` has block scope, and `const` is used for constants.

20. **What are closures in JavaScript?**
   - Closures are functions that have access to variables from their outer function scope even after the outer function has returned.

21. **Difference between find() and findOne() in MongoDB?**
   - `find()` returns an array of documents, while `findOne()` returns the first matching document.

22. **Difference between find and filter in JavaScript?**
   - `find()` returns the first matching element, while `filter()` returns an array of all matching elements.

23. **Difference between PUT and PATCH?**
   - PUT updates the entire resource, while PATCH updates specific fields of a resource.

24. **What is MVC structure?**
   - MVC (Model-View-Controller) is a design pattern that separates application logic into three interconnected components.

25. **Difference between SPA and MPA?**
   - SPA (Single Page Application) loads a single HTML page and dynamically updates content, whereas MPA (Multiple Page Application) loads new pages from the server.

26. **What are aggregation pipelines?**
   - Aggregation pipelines in MongoDB process data in stages such as filtering, grouping, and transforming.

27. **How to get all products in the controller?**
   - Use `Product.find()` in the controller function to fetch all product records from MongoDB.

28. **How to get all products in React.js?**
   - Use `fetch` or `axios` to call the API and retrieve product data.

29. **What is $lookup in MongoDB?**
   - `$lookup` is used to perform joins between different collections in MongoDB.

30. **Why use $lookup in MongoDB?**
   - To combine data from multiple collections similar to SQL joins.

31. **Why use React.js?**
   - React provides component-based architecture, fast rendering, and state management for building scalable applications.

32. **What are props in React?**
   - Props are inputs passed to components to make them reusable.

33. **How many hooks in React.js and which?**
   - Some important hooks include `useState`, `useEffect`, `useContext`, `useReducer`, `useMemo`, `useRef`, and `useCallback`.

Hook	When to Use
useState  	   Manage component-level state
useEffect	   Handle side effects
useContext	   Avoid prop drilling
useReducer	   Complex state management with actions
useMemo      	Optimize expensive computations
useRef	      Persist values without re-rendering
useCallback	   Prevent function recreation for performance


34. **Why use components in React.js?**
   - Components make code reusable, maintainable, and modular.

35. **What is CRUD?**
   - CRUD stands for Create, Read, Update, and Delete operations.

36. **What is JSX?**
   - JSX is a syntax extension for JavaScript that allows writing HTML-like code within React components.

37. **Difference between map() and forEach() in JavaScript?**
   - `map()` returns a new array, whereas `forEach()` does not return anything.

38. **What is Tailwind CSS?**
   - Tailwind CSS is a utility-first CSS framework for rapidly building custom designs.

39. **Why use Tailwind CSS?**
   - Tailwind provides utility classes that allow for faster styling without writing custom CSS.

40. **What are keys in React?**
   - Keys are unique identifiers for elements in lists to help React identify changes efficiently.

41. **Why use keys in React.js?**
   - To optimize rendering by helping React distinguish elements when they are added, removed, or changed.

42. **What happens if keys are not used in React?**
   - Without keys, React may not update elements correctly, leading to potential UI bugs and performance issues.



React

1. **What is React?**
   - React is a JavaScript library for building user interfaces, focusing on component-based architecture and efficient rendering using a virtual DOM.

2. **What are the advantages of using React?**
   - Component reusability, virtual DOM for faster updates, unidirectional data flow, strong community support, and efficient rendering.

3. **What are the limitations of React?**
   - SEO challenges, steep learning curve for beginners, and requirement of additional libraries for state management and routing.

4. **What is useState() in React?**
   - useState() is a Hook that allows functional components to manage state by returning a state variable and a function to update it.

5. **What are the keys in React?**
   - Keys are unique identifiers for elements in lists to help React identify changes efficiently.

6. **What is JSX?**
   - JSX is a syntax extension for JavaScript that allows writing HTML-like code within React components.

7. **What are the differences between functional and class components?**
   - Functional components are stateless and simpler, while class components support state and lifecycle methods.

8. **What is the virtual DOM? How does React use the virtual DOM to render the UI?**
   - Virtual DOM is a lightweight copy of the real DOM; React updates it first, then efficiently updates only the changed parts of the real DOM.

9. **What are the differences between controlled and uncontrolled components?**
   - Controlled components have state managed by React, 
     whereas uncontrolled components manage their state using the DOM.

10. **What are props in React?**
   - Props are inputs passed to components to make them reusable and dynamic.

11. **Explain the React state and props.**
   - State is internal and mutable, while props are external and immutable.

12. **Explain about types of side effects in the React component.**
   - Side effects include data fetching, subscriptions, and manually changing the DOM.

13. **What is prop drilling in React?**
   - Prop drilling refers to passing props down multiple levels of components.

14. **What are error boundaries?**
   - Error boundaries are React components that catch JavaScript errors in child components and display a fallback UI.

15. **What are React Hooks?**
   - Hooks are functions that allow functional components to use state and lifecycle features.

16. **Explain React Hooks.**
   - React Hooks allow the use of state and other React features in functional components.

17. **What are the rules that must be followed while using React Hooks?**
   - Hooks should only be called at the top level of a component and inside React functional components.

18. **What is the use of useEffect React Hooks?**
   - useEffect is used to perform side effects in components such as data fetching and DOM manipulation.

19. **Why do React Hooks make use of refs?**
   - Refs allow access to DOM elements and persist values across renders without causing re-renders.

20. **What are Custom Hooks?**
   - Custom Hooks are reusable functions that encapsulate logic using existing React Hooks.

21. **Explain Strict Mode in React.**
   - Strict Mode is a tool for highlighting potential problems in an application by running additional checks.

22. **How to prevent re-renders in React?**
   - Use React.memo, useCallback, and useMemo to prevent unnecessary re-renders.

23. **What are the different ways to style a React component?**
   - Inline styles, CSS modules, styled-components, and Tailwind CSS.

24. **Name a few techniques to optimize React app performance.**
   - Code splitting, lazy loading, memoization, and using efficient state management.

25. **How to pass data between React components?**
   - Using props, context API, or state management libraries like Redux.

26. **What are Higher Order Components?**
   - Higher Order Components (HOCs) are functions that take a component and return a new component with additional functionality.

27. **What are the different phases of the component lifecycle?**
   - Mounting, updating, and unmounting phases.

28. **What are the lifecycle methods of React?**
   - constructor, render, componentDidMount, componentDidUpdate, componentWillUnmount.

29. **Does React Hook work with static typing?**
   - Yes, with TypeScript, which provides static typing support.

30. **Explain about types of Hooks in React.**
   - Common Hooks include useState, useEffect, useContext, useRef, useReducer, useCallback, and useMemo.

31. **Differentiate React Hooks vs. Classes.**
   - Hooks provide a simpler and cleaner way to handle state and side effects compared to class components.

32. **How does the performance of using Hooks differ in comparison with the classes?**
   - Hooks reduce code complexity and improve maintainability, but both approaches have similar performance.

33. **Do Hooks cover all the functionalities provided by the classes?**
   - Yes, Hooks provide almost all functionalities with better readability and maintainability.

34. **What is React Router?**
   - React Router is a library for handling navigation in a React application.

35. **Can React Hook replace Redux?**
   - In some cases, React's Context API and useReducer can replace Redux, but Redux is still useful for complex state management.

36. **Explain conditional rendering in React.**
   - Conditional rendering allows rendering different components based on conditions.

37. **Explain how to create a simple React Hooks example program.**
   - Use useState and useEffect to manage and update state inside a functional component.

38. **How to create a switching component for displaying different pages?**
   - Use React Router's `Route` and `Switch` components.

39. **How to re-render the view when the browser is resized?**
   - Use the `useEffect` hook to listen to the window resize event and update the state accordingly.

40. **How to pass data between sibling components using a React router?**
   - Use React Context API or lift state up to a common parent component and pass via props.





javascript


1. **What is JavaScript? How does it differ from other programming languages?**
   - JavaScript is a high-level, interpreted programming language used primarily for web development. It allows for dynamic content updates, interactive user interfaces, and client-side scripting. Unlike other programming languages such as Python or Java, JavaScript runs in the browser and does not require compilation.

2. **Explain the difference between null and undefined in JavaScript.**
   - `null` is an assigned value representing the intentional absence of any object value.
   - `undefined` means a variable has been declared but has not been assigned a value.

3. **Discuss the role of ECMAScript in relation to JavaScript.**
   - ECMAScript (ES) is the standard on which JavaScript is based. It defines the language's syntax, features, and functionalities. JavaScript is an implementation of ECMAScript, and updates like ES6 introduce new features.

4. **What are the different data types in JavaScript?**
   - Primitive Types: `String`, `Number`, `Boolean`, `Null`, `Undefined`, `Symbol`, `BigInt`
   - Non-primitive Types: `Object`, `Array`, `Function`

5. **Explain the concept of hoisting in JavaScript.**
   - Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their containing scope before code execution. Only declarations are hoisted, not initializations.

6. **How does prototypal inheritance work in JavaScript?**
   - In JavaScript, objects can inherit properties and methods from another object via the prototype chain. Every object has an internal link to another object called its prototype.

7. **Explain the difference between var, let, and const in JavaScript.**
   - `var`: Function-scoped, hoisted, can be re-declared.
   - `let`: Block-scoped, cannot be re-declared, no hoisting issues.
   - `const`: Block-scoped, cannot be reassigned, used for constants.

8. **What is the scope of a variable declared using var, let, and const?**
   - `var`: Function scope.
   - `let` and `const`: Block scope.

9. **Discuss the concept of closures in JavaScript and their use cases.**
   - A closure is a function that remembers and accesses variables from its outer scope even after the outer function has finished executing. Use cases include data encapsulation and private variables.

10. **Explain callback functions and their significance in JavaScript.**
   - A callback function is a function passed as an argument to another function and executed later. It is crucial for asynchronous programming (e.g., handling API responses).

11. **Describe the differences between function declarations and function expressions in JavaScript.**
   - Function Declaration: `function foo() {}` - Hoisted and available before execution.
   - Function Expression: `const foo = function() {}` - Not hoisted.

12. **What are arrow functions, and how do they differ from regular functions?**
   - Arrow functions provide a shorter syntax and do not bind their own `this` value, making them useful in callbacks and functional programming.

13. **How do you access and manipulate the DOM using JavaScript?**
   - Use methods like `document.getElementById()`, `querySelector()`, and properties such as `innerHTML`, `style`, and event handlers.

14. **Explain event bubbling and event delegation in JavaScript.**
   - Event bubbling: Events propagate from the target element up to the parent elements.
   - Event delegation: Event listeners are added to parent elements to handle events from child elements.

15. **What are the different ways to handle events in JavaScript?**
   - Inline event handlers, `addEventListener()`, and event properties like `onclick`.

16. **Discuss the purpose and usage of event.preventDefault() in JavaScript.**
   - It prevents the default action of an element (e.g., prevents a form from submitting when clicking a button).

17. **Explain the concept of asynchronous programming in JavaScript.**
   - Asynchronous programming allows tasks to run in the background without blocking code execution, using techniques like callbacks, Promises, and async/await.

18. **How do callbacks, Promises, and async/await aid in handling asynchronous operations?**
   - Callbacks: Handle asynchronous tasks but lead to callback hell.
   - Promises: Provide better readability and chaining with `.then()`.
   - async/await: Simplifies asynchronous code with synchronous-like syntax.

19. **Discuss the significance of the event loop in JavaScript.**
   - The event loop handles asynchronous operations by continuously checking the message queue and executing tasks when the call stack is empty.

20. **Explain some new features introduced in ES6 (ECMAScript 2015) and their benefits.**
   - `let` and `const` for better scoping.
   - Arrow functions for concise syntax.
   - Template literals for string interpolation.
   - Destructuring assignment.
   - Default parameters.
   - Spread/rest operators.
   - Promises for better asynchronous handling.
   - Modules (import/export) for better code organization.

21. **Discuss the purpose and usage of template literals in JavaScript.**
   - Template literals, introduced in ES6, allow for easier string manipulation using backticks (`` ` ``) instead of quotes. They enable multi-line strings, string interpolation using `${expression}`, and embedded expressions.
   - Example:
     ```js
     const name = "John";
     console.log(`Hello, ${name}!`); // Output: Hello, John!
     ```

22. **What are destructuring assignments, and how are they used in JavaScript?**
   - Destructuring allows extracting values from arrays or objects into distinct variables.
   - Example:
     ```js
     const [a, b] = [1, 2];
     const {name, age} = {name: "Alice", age: 25};
     ```

23. **How do you handle errors and exceptions in JavaScript?**
   - Use `try...catch` blocks to catch runtime errors.
   - Use `throw` to manually trigger exceptions.
   - Example:
     ```js
     try {
       JSON.parse("invalid json");
     } catch (error) {
       console.error("Parsing error", error);
     }
     ```

24. **Explain the significance of try...catch blocks in error handling.**
   - They help prevent application crashes by catching exceptions and providing alternative flows.
   - Useful for handling synchronous code and JSON parsing.

25. **What tools or techniques do you use for debugging JavaScript code?**
   - Browser DevTools (Chrome, Firefox)
   - `console.log()` for logging values
   - Breakpoints and watch expressions
   - Linters like ESLint

26. **Discuss some best practices for writing clean and maintainable JavaScript code.**
   - Follow naming conventions
   - Use meaningful variable names
   - Modularize code using functions and modules
   - Avoid global variables
   - Write DRY (Don't Repeat Yourself) code

27. **How can you optimize JavaScript code for better performance?**
   - Minify and bundle JS files
   - Debounce and throttle events
   - Avoid unnecessary DOM manipulations
   - Use efficient algorithms and data structures

28. **Have you worked with any JavaScript frameworks or libraries (e.g., React, Angular, Vue)?**
   - Yes, primarily with React. React's component-based structure allows for reusable UI elements, and its virtual DOM enhances performance.

29. **Discuss the concepts of currying and memoization in JavaScript.**
   - **Currying:** Transforming a function with multiple arguments into a sequence of functions each taking a single argument.
     ```js
     const add = a => b => a + b;
     console.log(add(2)(3)); // 5
     ```
   - **Memoization:** Caching function results to improve performance.

30. **Explain the concept of Promises chaining and error handling within promise chains.**
   - Promises chaining allows sequential execution of asynchronous operations.
   - Example:
     ```js
     fetch('url')
       .then(response => response.json())
       .then(data => console.log(data))
       .catch(error => console.error(error));
     ```

31. **What is the Event Loop in JavaScript? How does it contribute to the asynchronous nature of JavaScript?**
   - The event loop manages execution of asynchronous operations by handling tasks in the callback queue after completing the call stack.

32. **What is the purpose of the 'use strict' statement in JavaScript?**
   - Enforces a stricter parsing and error handling in JS code to prevent common mistakes (e.g., undeclared variables).
   - Example:
     ```js
     "use strict";
     x = 10; // Throws an error
     ```

33. **Discuss the differences between the apply, call, and bind methods in JavaScript.**
   - `call`: Invokes a function with arguments passed individually.
   - `apply`: Similar to `call`, but takes arguments as an array.
   - `bind`: Returns a new function with `this` bound to a specific value.
   - Example:
     ```js
     function greet(name) { console.log(this.msg + ' ' + name); }
     greet.call({msg: 'Hello'}, 'John');
     ```

34. **Explain the concept of currying and provide an example of its use in JavaScript.**
   - Currying is breaking down a function with multiple arguments into smaller functions.
   - Example:
     ```js
     const multiply = x => y => x * y;
     const double = multiply(2);
     console.log(double(5)); // 10
     ```

35. **What is a closure in JavaScript, and how does it impact variable scope?**
   - A closure is a function that retains access to its outer scope.
   - Example:
     ```js
     function outer() {
       let count = 0;
       return function inner() { count++; console.log(count); };
     }
     const counter = outer();
     counter(); // 1
     ```

36. **Explain the difference between arrays and linked lists. When would you use one over the other?**
   - Arrays allow indexed access, while linked lists consist of nodes connected via references.
   - Arrays are better for fast lookup; linked lists are preferred for dynamic data insertion/deletion.

37. **What are some sorting algorithms used in JavaScript? Provide examples and their time complexity.**
   - Common sorting algorithms include:
     - Bubble Sort: `O(n^2)`
     - Merge Sort: `O(n log n)`
     - Quick Sort: `O(n log n)`
     ```js
     arr.sort((a, b) => a - b); // Quick sort
     ```

38. **Discuss the concepts of stacks and queues and how they are implemented in JavaScript.**
   - **Stack:** LIFO (Last-In-First-Out)
     ```js
     const stack = [];
     stack.push(1);
     stack.pop();
     ```
   - **Queue:** FIFO (First-In-First-Out)
     ```js
     const queue = [];
     queue.push(1);
     queue.shift();
     ```

39. **Explain the concept of recursion and provide an example of a recursive function in JavaScript.**
   
   Recursion is a programming technique where a function calls itself to solve smaller instances of the same problem until a base condition is met.
   
   Example:
   ```javascript
   function factorial(n) {
       if (n === 0) return 1;  // Base case
       return n * factorial(n - 1); // Recursive call
   }
   console.log(factorial(5)); // Output: 120
   ```

40. **What are the key differences between React, Vue, and Angular? When would you choose one over the others?**

   - **React:** Component-based, virtual DOM, unidirectional data flow, high flexibility, used for large-scale applications.
   - **Vue:** Lightweight, simple API, two-way data binding, great for small to medium projects.
   - **Angular:** Full-fledged framework, two-way data binding, dependency injection, best for enterprise-level applications.
   
   Choose React for flexibility, Vue for simplicity, and Angular for complex applications.

41. **Explain the Virtual DOM and its significance in libraries like React.**

   The Virtual DOM is a lightweight representation of the actual DOM. It allows React to update only the parts of the UI that change, improving performance by minimizing direct DOM manipulation.

42. **How does state management work in React? Discuss different approaches, such as using Context API or Redux.**

   - **Context API:** Built-in, used for small to medium applications to avoid prop drilling.
   - **Redux:** Centralized state management, used for large applications requiring predictable state changes.

43. **Discuss the concept of components in frontend frameworks and libraries, their importance, and best practices for creating them.**

   Components are reusable UI elements that encapsulate structure, behavior, and styling. Best practices include keeping components small, reusable, and avoiding deep nesting.

44. **Discuss modern JavaScript APIs like fetch, localStorage, and the use cases for each.**

   - **fetch:** Handles HTTP requests asynchronously.
   - **localStorage:** Stores key-value pairs in the browser persistently.

45. **How do you implement client-side routing in a single-page application using JavaScript?**

   Use libraries like React Router to map URL paths to components and enable navigation without full page reloads.

46. **Explain the differences between callbacks and Promises. When would you prefer one over the other?**

   - Callbacks handle asynchronous tasks by passing a function to another function.
   - Promises provide better readability and error handling.
   - Prefer Promises for cleaner code and better error management.

47. **How do you handle errors in Promises? Discuss the best practices for error handling in Promises.**

   Use `.catch()` to handle errors gracefully and `try...catch` when using `async/await` syntax.

48. **What are Async/Await in JavaScript? How do they simplify asynchronous code?**

   Async/Await provides a synchronous style syntax for writing asynchronous code, making it more readable and easier to handle errors.

49. **Discuss the advantages of using TypeScript over JavaScript.**

   - Static typing.
   - Improved code maintainability.
   - Better tooling and autocompletion support.

50. **Explain the concepts of map, reduce, and filter in JavaScript.**

   - **map:** Transforms elements and returns a new array.
   - **reduce:** Aggregates values into a single result.
   - **filter:** Filters elements based on conditions.

51. **What are some performance optimization techniques for JavaScript applications?**

   - Minify code.
   - Use lazy loading.
   - Optimize loops.
   - Reduce DOM manipulation.

52. **How do you use the Geolocation API in JavaScript? Provide an example.**

   ```javascript
   navigator.geolocation.getCurrentPosition(position => {
       console.log(position.coords.latitude, position.coords.longitude);
   });
   ```

53. **Discuss the localStorage and sessionStorage APIs and their differences.**

   - **localStorage:** Persistent storage until manually cleared.
   - **sessionStorage:** Data persists until the session ends.

54. **Explain the spread operator and its applications in JavaScript.**

   The spread operator (`...`) expands elements of an array or object.
   
   Example:
   ```javascript
   const arr1 = [1, 2];
   const arr2 = [...arr1, 3, 4];
   ```

55. **Discuss the purpose and use cases for generators and iterators in JavaScript.**

   Generators produce values lazily using the `yield` keyword, useful for handling large datasets efficiently.

56. **How does JavaScript interact with GraphQL APIs? Discuss libraries or methods used for making GraphQL requests from the client-side.**

   JavaScript interacts with GraphQL APIs using libraries like Apollo Client or fetch to send queries and mutations to a GraphQL server.

57. **What are WebSockets, and how are they used in real-time applications with JavaScript?**
   - WebSockets provide a persistent, full-duplex communication channel between the client and server. They are commonly used in real-time applications such as chat apps, online gaming, and live notifications.
   - Example:
     ```js
     const socket = new WebSocket('ws://example.com/socket');
     socket.onopen = () => socket.send('Hello Server');
     socket.onmessage = (event) => console.log('Message:', event.data);
     ```

58. **How can you handle internationalization and localization in JavaScript applications?**
   - Using libraries like `i18next` or `react-intl`.
   - Storing translations in JSON files and dynamically loading them based on the user's locale.
   - Example with `i18next`:
     ```js
     i18next.init({ resources: { en: { translation: { key: "Hello" } } } });
     console.log(i18next.t('key'));
     ```

59. **Explain the concept of stack trace and its significance in debugging JavaScript code.**
   - A stack trace shows the sequence of function calls leading to an error.
   - It helps developers pinpoint the source of an issue by tracking the call hierarchy.

60. **Discuss strategies to handle and troubleshoot memory leaks in JavaScript.**
   - Use browser dev tools to monitor memory usage.
   - Avoid global variables and event listeners that are not properly removed.
   - Use WeakMap and WeakSet for objects that can be garbage collected.

61. **Discuss the importance of code organization and best practices for structuring JavaScript projects.**
   - Use modular design with clear separation of concerns (e.g., MVC pattern).
   - Follow consistent naming conventions and documentation.
   - Use tools like ESLint to enforce coding standards.

62. **How do you manage dependencies and handle version control in JavaScript projects?**
   - Use `package.json` with npm or yarn.
   - Lock dependencies using `package-lock.json` or `yarn.lock`.
   - Use version control systems like Git for tracking changes.

63. **What are template literals in ES6? How do they differ from regular strings in JavaScript?**
   - Template literals allow multi-line strings and interpolation using backticks (`` ` ``).
   - Example:
     ```js
     let name = 'John';
     console.log(`Hello, ${name}`);
     ```

64. **Discuss the purpose and use of the destructuring assignment in JavaScript.**
   - It allows extracting values from objects/arrays into variables.
   - Example:
     ```js
     const { name, age } = { name: 'Alice', age: 25 };
     ```

65. **Explain the concept of default parameters in ES6 functions and their importance.**
   - Default values prevent `undefined` when no arguments are provided.
   - Example:
     ```js
     function greet(name = 'Guest') {
       console.log(`Hello, ${name}`);
     }
     ```

66. **What are some popular JavaScript build tools and bundlers? How do they streamline the development process?**
   - Webpack, Parcel, Rollup ‚Äì they bundle modules, optimize assets, and support hot module replacement.

67. **Explain the role of Babel in modern JavaScript development.**
   - Babel transpiles modern ES6+ code into compatible versions for older browsers.
   - Example in `.babelrc`:
     ```json
     { "presets": ["@babel/preset-env"] }
     ```

68. **How can you optimize the performance of a website by minimizing render-blocking resources?**
   - Load scripts asynchronously with `async`/`defer` attributes.
   - Use Content Delivery Networks (CDNs).
   - Optimize CSS and JavaScript file sizes.

69. **Discuss techniques for lazy loading images in JavaScript for enhanced performance.**
   - Use the `loading="lazy"` attribute.
   - Implement Intersection Observer API to load images on viewport entry.

70. **What are the core features of a Progressive Web App, and how does JavaScript play a role in building PWAs?**
   - Features: offline capabilities, push notifications, responsive design.
   - JavaScript is used to create service workers and manage caching.

71. **How can you implement service workers in a JavaScript-based web application?**
   - Example:
     ```js
     navigator.serviceWorker.register('/sw.js').then(() => console.log('Registered'));
     ```

72. **What testing frameworks have you used in JavaScript? Discuss the differences between Jest, Mocha, and Jasmine.**
   - Jest: easy setup, built-in mocking.
   - Mocha: flexible with third-party plugins.
   - Jasmine: behavior-driven development (BDD).

73. **Explain the purpose of mocking and stubbing in testing JavaScript applications.**
   - Mocking: simulating functions/modules.
   - Stubbing: pre-defining function behavior for tests.

74. **Discuss the purpose of React hooks and their advantages over class-based components.**
   - Hooks (e.g., `useState`, `useEffect`) simplify state management without classes.
   - Improved readability and reusability.


**75. How does state management work in React applications? Compare various state management libraries like Redux, MobX, and Context API.**  
State management in React allows components to manage and share state efficiently.  
- **Redux:** Centralized store, predictable state management, actions/reducers, suitable for large applications.  
- **MobX:** Reactive, flexible, easier to implement than Redux, mutable state management.  
- **Context API:** Built-in, lightweight, useful for passing data deeply in component trees but not ideal for complex states.  

---

**76. What is Node.js, and how does it differ from client-side JavaScript?**  
Node.js is a runtime environment that allows executing JavaScript outside the browser, built on the V8 engine. Unlike client-side JS, Node.js focuses on server-side operations like file handling, database interactions, and networking.  

---

**77. Discuss the event-driven architecture in Node.js and its significance in building scalable applications.**  
Node.js uses an event-driven, non-blocking architecture where I/O operations are handled asynchronously through event loops and callbacks, making it efficient and scalable for real-time applications.  

---

**78. Explain the differences between synchronous and asynchronous error handling in JavaScript.**  
- **Synchronous:** Errors are thrown and caught immediately within the same execution flow using `try...catch`.  
- **Asynchronous:** Errors occur later in async operations and are handled using `.catch()` with Promises or `try...catch` within `async/await` functions.  

---

**79. How do you handle unhandled promise rejections in JavaScript?**  
By using `.catch()` at the end of promise chains or global event handlers like `process.on('unhandledRejection', handler)` in Node.js.  

---

**80. Explain the difference between concurrency and parallelism in JavaScript.**  
- **Concurrency:** Multiple tasks can start but may not run at the same time (e.g., event loop in JS).  
- **Parallelism:** Multiple tasks run simultaneously (e.g., using worker threads in Node.js).  

---

**81. What are some methods to create smooth animations in JavaScript applications?**  
- Using **CSS animations** for simple tasks.  
- **requestAnimationFrame()** for high-performance JS animations.  
- Libraries like **GSAP** and **Anime.js** for complex animations.  

---

**82. How do you handle user interactions and gestures in JavaScript for touch-enabled devices?**  
Using touch events like `touchstart`, `touchmove`, and `touchend` or libraries such as Hammer.js for gesture recognition.  

---

**83. Discuss various debugging tools available for JavaScript and their key features.**  
- **Chrome DevTools:** Breakpoints, network monitoring, profiling.  
- **Node.js Debugger:** Built-in debugging via CLI.  
- **VS Code Debugger:** Integrated with modern JS frameworks.  

---

**84. How do you profile JavaScript applications for performance optimization?**  
Using Chrome DevTools' **Performance tab**, monitoring event loops, memory leaks, and optimizing critical render paths.  

---

**85. Explain the differences between capturing and bubbling phases of event propagation in JavaScript.**  
- **Capturing phase:** Events propagate from the root to the target element.  
- **Bubbling phase:** Events propagate from the target element back to the root.  

---

**86. How can you prevent event propagation in JavaScript? Provide examples.**  
By using `event.stopPropagation()` to prevent bubbling and `event.stopImmediatePropagation()` to stop further propagation in capturing or bubbling.  

```js
element.addEventListener('click', (event) => {
  event.stopPropagation();
});
```

---

**87. What tools or platforms do you use for error tracking and monitoring in JavaScript applications?**  
- **Sentry:** Error tracking and performance monitoring.  
- **LogRocket:** Session replays and issue tracking.  
- **New Relic:** Full-stack monitoring.  

---

**88. How can you integrate and utilize geospatial and map APIs, like Google Maps or Mapbox, in JavaScript applications?**  
Using their JavaScript SDKs to embed maps, geocode locations, and add custom layers via API keys and initialization functions.  

---

**89. What is WebAssembly, and how does it interact with JavaScript in web applications?**  
WebAssembly (Wasm) is a binary instruction format that allows high-performance execution of code written in languages like C/C++. It interacts with JS via the WebAssembly API to run heavy computations efficiently.  

---

**90. Explain the process of deploying JavaScript applications. How can CI/CD pipelines be set up for JavaScript projects?**  
Deployment involves:  
1. Building (e.g., using Webpack, Babel).  
2. Hosting (e.g., Vercel, Netlify, AWS).  
3. CI/CD using GitHub Actions, Jenkins, or GitLab CI for automated testing, linting, and deployment.  

---

**91. Explain the Module pattern in JavaScript and its advantages.**  
The Module pattern encapsulates functionality using closures to create private and public members, providing better code organization and avoiding global scope pollution.  

Example:  
```js
const modulePattern = (function() {
  let privateVar = 'secret';
  return {
    getVar: () => privateVar,
  };
})();
console.log(modulePattern.getVar()); // 'secret'
```

Advantages:  
- Encapsulation of data.  
- Avoids polluting the global namespace.  
- Promotes reusability and maintainability.  


**92. How can you integrate and interact with the Canvas API in JavaScript? Provide an example of drawing on the HTML5 canvas.**  
The Canvas API allows drawing graphics via JavaScript. You can use methods like `fillRect()`, `stroke()`, and `drawImage()` on the canvas.  

Example:  
```js
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'blue';
ctx.fillRect(50, 50, 100, 100);
```

---

**93. Discuss the Geolocation API and how it's utilized in JavaScript applications.**  
The Geolocation API provides access to a user's location through `navigator.geolocation`.  

Example:  
```js
navigator.geolocation.getCurrentPosition(position => {
  console.log(position.coords.latitude, position.coords.longitude);
});
```

---

**94. Explain the WebSocket protocol and how it's used for real-time communication in JavaScript applications.**  
WebSockets provide full-duplex communication between the client and server over a single persistent connection, used for chat apps, live updates, etc.  

Example:  
```js
const socket = new WebSocket('ws://example.com/socket');
socket.onmessage = event => console.log(event.data);
socket.send('Hello Server');
```

---

**95. How do you handle WebSocket connections in JavaScript? Provide examples.**  
You manage WebSocket connections using `onopen`, `onmessage`, `onclose`, and `onerror` events.  

Example:  
```js
const socket = new WebSocket('ws://example.com');
socket.onopen = () => socket.send('Connected');
socket.onmessage = event => console.log('Message:', event.data);
socket.onclose = () => console.log('Disconnected');
```

---

**96. Discuss code-splitting and lazy loading in JavaScript for optimizing web performance.**  
Code-splitting divides code into smaller chunks, and lazy loading loads resources only when needed. Tools like Webpack and React's `React.lazy()` help achieve this.  

Example:  
```js
const LazyComponent = React.lazy(() => import('./MyComponent'));
```

---

**97. How can you minimize render-blocking resources in a web application to improve loading times?**  
- Defer JavaScript (`<script defer>`)  
- Minify CSS/JS  
- Use asynchronous loading (`async`)  
- Optimize critical rendering path  

---

**98. Explain the concept of micro-frontends and their implementation using JavaScript frameworks/libraries.**  
Micro-frontends break a UI into independent, smaller apps owned by different teams. They can be implemented using frameworks like React or Angular within Web Components.  

---

**99. Discuss the advantages and challenges of micro-frontends in JavaScript-based applications.**  
**Advantages:** Scalable, independent deployment, team autonomy.  
**Challenges:** Increased complexity, dependency management.  

---

**100. How does npm differ from yarn in managing JavaScript dependencies?**  
- **npm:** Default package manager, slower, uses `package-lock.json`.  
- **yarn:** Faster, parallel installations, uses `yarn.lock`.  

---

**101. Discuss the use of UI frameworks or component libraries like Material-UI, Ant Design, or Bootstrap in JavaScript applications.**  
These libraries provide pre-designed components for consistent UI and faster development. Material-UI is React-based, Ant Design is for enterprise-level UI, and Bootstrap is framework-agnostic.  

---

**102. What are the basic data types in JavaScript?**  
`String`, `Number`, `Boolean`, `Object`, `Array`, `Null`, `Undefined`, `Symbol`, `BigInt`.  

---

**103. Explain the difference between null and undefined.**  
- **null:** Explicitly assigned absence of value.  
- **undefined:** Variable declared but not assigned a value.  

---

**104. Discuss variable scope and hoisting in JavaScript.**  
- **Scope:** Determines variable accessibility (global, function, block).  
- **Hoisting:** Variables and functions are moved to the top of their scope during execution.  

---

**105. What is the purpose of the 'use strict' directive in JavaScript?**  
It enforces a stricter parsing mode, preventing silent errors and disallowing certain practices.  

---

**106. Explain the difference between function declarations and function expressions.**  
- **Declaration:** `function foo() {}` (hoisted).  
- **Expression:** `const foo = function() {};` (not hoisted).  

---

**107. What is a closure in JavaScript, and how is it useful?**  
A closure allows functions to retain access to the scope in which they were created.  

Example:  
```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const counter = outer();
counter();
```

---

**108. How do you handle asynchronous operations in JavaScript?**  
Using callbacks, Promises, and async/await.  

---

**109. Discuss some new features introduced in ES6 (ECMAScript 2015).**  
Arrow functions, let/const, template literals, classes, default parameters, destructuring, modules.  

---

**110. What are arrow functions, and how do they differ from regular functions?**  
Arrow functions have shorter syntax and lexically bind `this`.  

---

**111. How do you access and manipulate the DOM in JavaScript?**  
Using methods like `getElementById`, `querySelector`, `innerHTML`, and `appendChild`.  

---

**112. Explain event delegation and how it's used in event handling.**  
Attaching a single event listener to a parent element to manage multiple child events.  

---

**113. How do you handle errors and exceptions in JavaScript?**  
Using `try...catch`, `throw` statements, and `.catch()` for Promises.  

---

**114. Discuss common debugging techniques in JavaScript.**  
Using `console.log()`, breakpoints, DevTools, and `debugger` statements.  

---

**115. How do you loop through an array in JavaScript?**  
Using `forEach()`, `map()`, `for...of`, and traditional for-loops.  

---

**116. Explain the concept of object-oriented programming in JavaScript.**  
OOP in JS is based on prototypes and ES6 classes for encapsulation and reusability.  

---

**117. How can you clone an object in JavaScript?**  
Using `Object.assign({}, obj)` or spread operator `{ ...obj }`.  

---

**118. Explain the purpose of Promises in JavaScript and how they handle asynchronous operations.**  
Promises represent asynchronous operations that can resolve or reject.  

---

**119. Discuss the async/await feature and its benefits in handling asynchronous code.**  
Simplifies handling of Promises, making code look synchronous and readable.  

---

**120. Explain variable scope in JavaScript and how it affects closures.**  
Closures capture variables from the outer scope in which they are defined.  

---

**121. What is the difference between global scope and local scope in JavaScript?**  
Global variables are accessible everywhere, local variables exist within a function/block.  

---

**122. Discuss the capturing and bubbling phases of event propagation in JavaScript.**  
Events first go down (capturing) and then up (bubbling) the DOM tree.  
